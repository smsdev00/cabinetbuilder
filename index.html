<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Corte MDF v2.0</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #3b82f6;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --dark-color: #1e293b;
            --light-bg: #f8fafc;
        }
        
        body { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px 0;
        }
        
        #app { 
            /* max-width: 1400px; */
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .main-card {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header-section {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 2rem;
            text-align: center;
        }
        
        .header-section h1 {
            font-size: 2rem;
            font-weight: 700;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .header-section .version {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 0.5rem;
        }
        
        .input-card {
            border: none;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            height: 100%;
        }
        
        .input-card:hover {
            box-shadow: 0 8px 25px rgba(0,0,0,0.12);
            transform: translateY(-2px);
        }
        
        .input-card .card-header {
            background: linear-gradient(135deg, var(--light-bg) 0%, #e2e8f0 100%);
            font-weight: 600;
            border: none;
            padding: 1rem 1.5rem;
            border-radius: 15px 15px 0 0 !important;
        }
        
        .form-control, .form-select {
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 0.75rem;
            transition: all 0.3s ease;
        }
        
        .form-control:focus, .form-select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(37, 99, 235, 0.15);
        }
        
        .form-label {
            font-weight: 600;
            color: var(--dark-color);
            margin-bottom: 0.5rem;
        }
        
        .results-banner {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
            margin-bottom: 2rem;
        }
        
        .results-banner.error {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }
        
        .stat-box {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.2);
            padding: 0.75rem 1.25rem;
            border-radius: 10px;
            margin: 0.5rem;
            backdrop-filter: blur(10px);
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        .info-note {
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border-left: 4px solid var(--primary-color);
            padding: 1.25rem;
            border-radius: 10px;
            margin: 1.5rem 0;
        }
        
        .info-note-warning {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-left-color: var(--warning-color);
        }
        
        .table-modern {
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .table-modern thead {
            background: linear-gradient(135deg, var(--dark-color) 0%, #334155 100%);
        }
        
        .table-modern tbody tr {
            transition: all 0.2s ease;
        }
        
        .table-modern tbody tr:hover {
            background-color: var(--light-bg);
            transform: scale(1.01);
        }
        
        .piece-color-indicator {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .sheet-layout-container {
            position: relative;
            border: 3px solid var(--dark-color);
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            margin: 1rem auto;
            overflow: hidden;
        }
        
        .board-header {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--dark-color);
            margin-bottom: 0.75rem;
            text-align: center;
            padding: 0.5rem;
            background: var(--light-bg);
            border-radius: 8px;
        }
        
        .placed-piece {
            position: absolute;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .placed-piece:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        #renderer-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            margin: 1.5rem 0;
        }
        
        #renderer-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        
        .renderer-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            text-align: center;
        }
        
        .controls-panel {
            background: var(--light-bg);
            border-radius: 15px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border: 1px solid #e2e8f0;
        }
        
        .control-section {
            margin-bottom: 1.5rem;
        }
        
        .control-section h4 {
            color: var(--dark-color);
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary-color);
        }
        
        .form-check-modern {
            background: white;
            padding: 0.75rem 1rem;
            border-radius: 10px;
            margin-bottom: 0.75rem;
            border: 2px solid #e2e8f0;
            transition: all 0.2s ease;
        }
        
        .form-check-modern:hover {
            border-color: var(--primary-color);
            background: #f8fafc;
        }
        
        .form-check-modern .form-check-input {
            width: 3em;
            height: 1.5em;
            margin-top: 0;
        }
        
        .form-check-modern .form-check-input:checked {
            background-color: var(--success-color);
            border-color: var(--success-color);
        }
        
        .btn-modern {
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .btn-modern:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .btn-primary-modern {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
        }
        
        .btn-success-modern {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }
        
        .door-controls .btn {
            margin: 0.25rem;
        }
        
        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .preset-btn {
            padding: 0.5rem 1rem;
            border-radius: 8px;
            border: 2px solid var(--primary-color);
            background: white;
            color: var(--primary-color);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .preset-btn:hover {
            background: var(--primary-color);
            color: white;
        }
        
        .optimization-info {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border: 2px solid var(--success-color);
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .efficiency-bar {
            height: 25px;
            background: #e2e8f0;
            border-radius: 20px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .efficiency-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color) 0%, #34d399 100%);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 0.85rem;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .section-divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            margin: 2rem 0;
        }
        
        @media (max-width: 768px) {
            .header-section h1 {
                font-size: 1.5rem;
            }
            
            .stat-box {
                display: flex;
                width: 100%;
                margin: 0.5rem 0;
            }
            
            #renderer-container {
                height: 350px;
            }
        }
    </style>
</head>
<body>
    <div id="app" class="container-fluid">
        <div class="main-card">
            <div class="header-section">
                <h1> Calculadora Optimizada de Corte MDF</h1>
                <div class="version">Versión 2.0 - Mejorada y Optimizada</div>
            </div>
            
            <!--Presets Rápidos -->
            <!--<div class="p-4">
                <div class="info-note mb-4">
                    <h5 class="fw-bold mb-2">⚡ Presets Rápidos</h5>
                    <p class="mb-2 small">Carga configuraciones predefinidas para comenzar rápidamente:</p>
                    <div class="preset-buttons">
                        <button @click="loadPreset('alacena')" class="preset-btn">Alacena Cocina</button>
                        <button @click="loadPreset('biblioteca')" class="preset-btn">Biblioteca</button>
                        <button @click="loadPreset('mesita')" class="preset-btn">Mesita de Luz</button>
                        <button @click="loadPreset('placard')" class="preset-btn">Placard Simple</button>
                    </div>
                </div>-->

                <!-- Inputs -->
                <div class="row g-4 mb-4">
                    <div class="col-lg-6">
                        <div class="input-card card">
                            <div class="card-header">
                                Dimensiones del Mueble
                            </div>
                            <div class="card-body">
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <label for="largo" class="form-label">Largo (cm)</label>
                                        <input type="number" id="largo" class="form-control" v-model.number="largo" min="1" step="0.1">
                                    </div>
                                    <div class="col-md-6">
                                        <label for="ancho" class="form-label">Ancho/Profundidad (cm)</label>
                                        <input type="number" id="ancho" class="form-control" v-model.number="ancho" min="1" step="0.1">
                                    </div>
                                    <div class="col-md-6">
                                        <label for="alto" class="form-label">Alto (cm)</label>
                                        <input type="number" id="alto" class="form-control" v-model.number="alto" min="1" step="0.1">
                                    </div>
                                    <div class="col-md-6">
                                        <label for="espesor" class="form-label">Espesor Material (mm)</label>
                                        <select id="espesor" class="form-select" v-model.number="espesor">
                                            <option :value="5.5">5.5mm (Fino)</option>
                                            <option :value="9">9mm (Estándar)</option>
                                            <option :value="12">12mm (Medio)</option>
                                            <option :value="15">15mm (Grueso)</option>
                                            <option :value="18">18mm (Extra Grueso)</option>
                                        </select>
                                    </div>
                                    <div class="col-12">
                                        <label for="luzPuertas" class="form-label">Separación entre Puertas (cm)</label>
                                        <input type="number" id="luzPuertas" class="form-control" v-model.number="luzPuertas" min="0" max="5" step="0.1">
                                        <small class="text-muted">Espacio entre las dos puertas frontales</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-lg-6">
                        <div class="input-card card">
                            <div class="card-header">
                                Datos de la Placa MDF
                            </div>
                            <div class="card-body">
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <label for="sheetHeight" class="form-label">Alto Placa (cm)</label>
                                        <input type="number" id="sheetHeight" class="form-control" v-model.number="sheetHeight" min="1">
                                    </div>
                                    <div class="col-md-6">
                                        <label for="sheetWidth" class="form-label">Ancho Placa (cm)</label>
                                        <input type="number" id="sheetWidth" class="form-control" v-model.number="sheetWidth" min="1">
                                    </div>
                                    <div class="col-12">
                                        <label for="boardPrice" class="form-label">Precio por Placa ($)</label>
                                        <input type="number" id="boardPrice" class="form-control" v-model.number="boardPrice" min="0" step="any">
                                    </div>
                                    <div class="col-12">
                                        <label for="kerfWidth" class="form-label">Ancho de Corte/Kerf (mm)</label>
                                        <input type="number" id="kerfWidth" class="form-control" v-model.number="kerfWidth" min="0" max="10" step="0.1">
                                        <small class="text-muted">Pérdida de material por corte de sierra</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Resultados -->
                <div :class="['results-banner', resultadoCorte.error ? 'error' : '']">
                    <div class="text-center">
                        <div v-if="!resultadoCorte.error">
                            <div class="stat-box">
                                <span class="stat-label"> Placas:</span>
                                <span class="stat-value">{{ resultadoCorte.count }}</span>
                            </div>
                            <div class="stat-box">
                                <span class="stat-label"> Costo:</span>
                                <span class="stat-value">{{ formatCurrency(resultadoCorte.totalPrice) }}</span>
                            </div>
                            <div class="stat-box">
                                <span class="stat-label"> Eficiencia:</span>
                                <span class="stat-value">{{ efficiency }}%</span>
                            </div>
                        </div>
                        <div v-else class="text-white">
                            <strong> Error:</strong> {{ resultadoCorte.error }}
                        </div>
                    </div>
                </div>

                <!-- Información de Eficiencia -->
                <div v-if="!resultadoCorte.error && resultadoCorte.count > 0" class="optimization-info">
                    <h5 class="fw-bold mb-2"> Análisis de Aprovechamiento</h5>
                    <p class="mb-2">Material utilizado vs. disponible en las placas</p>
                    <div class="efficiency-bar">
                        <div class="efficiency-fill" :style="{width: efficiency + '%'}">
                            {{ efficiency }}% aprovechado
                        </div>
                    </div>
                    <small class="text-muted d-block mt-2">
                        Área total piezas: {{ totalPiecesArea.toFixed(2) }} cm² | 
                        Área total placas: {{ totalBoardsArea.toFixed(2) }} cm² |
                        Desperdicio: {{ wasteArea.toFixed(2) }} cm² ({{ (100 - efficiency).toFixed(1) }}%)
                    </small>
                </div>

                <div class="section-divider"></div>

                <!-- Vista 3D -->
                <div class="mb-4">
                    <h3 class="text-center mb-3 fw-bold"> Visualización 3D Interactiva</h3>
                    <div id="renderer-container" ref="rendererContainer">
                        <div v-if="!isRendererReady" class="renderer-placeholder">
                            <div class="loading-spinner mb-2"></div>
                            <div>Cargando visor 3D...</div>
                        </div>
                        <div v-if="isRendererReady && renderError" class="renderer-placeholder text-danger">
                             Error: {{ renderError }}
                        </div>
                    </div>
                    
                    <!-- Controles 3D -->
                    <div class="controls-panel">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="control-section">
                                    <h4> Visibilidad de Piezas</h4>
                                    <div v-if="!isRendererReady" class="text-center text-muted">
                                        Generando controles...
                                    </div>
                                    <template v-else>
                                        <div v-for="(visible, type) in pieceTypeVisibility" :key="type" class="form-check-modern form-check form-switch">
                                            <input class="form-check-input" type="checkbox" :id="'check-' + type" v-model="pieceTypeVisibility[type]">
                                            <label class="form-check-label" :for="'check-' + type">
                                                {{ getPieceLabel(type) }}
                                            </label>
                                        </div>
                                    </template>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="control-section">
                                    <h4> Control de Puertas</h4>
                                    <div v-if="!isRendererReady" class="text-center text-muted">
                                        Esperando modelo 3D...
                                    </div>
                                    <div v-else class="door-controls">
                                        <button @click="toggleDoorLeft" class="btn btn-modern btn-primary-modern" :disabled="!pieceTypeVisibility['Puerta']">
                                            {{ isDoorLeftOpen ? ' Cerrar' : ' Abrir' }} Puerta Izq.
                                        </button>
                                        <button @click="toggleDoorRight" class="btn btn-modern btn-primary-modern" :disabled="!pieceTypeVisibility['Puerta']">
                                            {{ isDoorRightOpen ? ' Cerrar' : ' Abrir' }} Puerta Der.
                                        </button>
                                        <button @click="resetCamera" class="btn btn-modern btn-success-modern">
                                             Resetear Vista
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section-divider"></div>

                <!-- Tabla de Despiece -->
                <div class="mb-4">
                    <h3 class="text-center mb-3 fw-bold"> Despiece Detallado</h3>
                    <div class="table-responsive">
                        <table class="table table-modern table-striped table-hover">
                            <thead class="text-white">
                                <tr>
                                    <th>Pieza</th>
                                    <th>Cód.</th>
                                    <th>Cant.</th>
                                    <th>Medida 1 (cm)</th>
                                    <th>Medida 2 (cm)</th>
                                    <th>Color</th>
                                    <th>Área (cm²)</th>
                                    <th>Notas</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-if="piezasCalculadas.length === 0 || piezasCalculadas[0].etiqueta === 'Error'">
                                    <td colspan="8" class="text-center fst-italic text-muted">
                                        {{ piezasCalculadas.length > 0 ? piezasCalculadas[0].dim1 : 'Ingrese dimensiones válidas.' }}
                                    </td>
                                </tr>
                                <tr v-else v-for="pieza in piezasCalculadas" :key="pieza.etiqueta + pieza.dim1 + pieza.dim2">
                                    <td class="fw-bold">{{ pieza.etiqueta }}</td>
                                    <td><span class="badge bg-secondary">{{ pieza.shortCode }}</span></td>
                                    <td>{{ pieza.cantidad }}</td>
                                    <td>{{ formatDecimal(pieza.dim1) }}</td>
                                    <td>{{ formatDecimal(pieza.dim2) }}</td>
                                    <td><span class="piece-color-indicator" :style="{ backgroundColor: pieza.color }"></span></td>
                                    <td>{{ formatDecimal(pieza.dim1 * pieza.dim2 * pieza.cantidad) }}</td>
                                    <td class="small">{{ pieza.nota || '-' }}</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="section-divider"></div>

                <!-- Planos de Corte -->
                <div class="mb-4">
                    <h3 class="text-center mb-3 fw-bold"> Planos de Corte Optimizados</h3>
                    <p v-if="resultadoCorte.count > 0 && !resultadoCorte.error" class="text-center text-muted mb-4">
                        Distribución optimizada de piezas en las placas MDF
                    </p>
                    <div v-if="resultadoCorte.boardData && resultadoCorte.boardData.length > 0 && !resultadoCorte.error" class="row">
                        <div v-for="board in resultadoCorte.boardData" :key="board.id" class="col-lg-6 mb-4">
                            <div class="board-header">
                                 Placa #{{ board.id }} 
                                <small class="text-muted">({{ board.pieces.length }} piezas)</small>
                            </div>
                            <div class="sheet-layout-container" :style="{ aspectRatio: sheetWidth / sheetHeight, maxWidth: '600px' }">
                                <div v-for="piece in board.pieces" :key="piece.id" 
                                     class="placed-piece" 
                                     :style="getPieceStyle(piece, sheetWidth, sheetHeight)" 
                                     :title="getPieceTooltip(piece)">
                                    {{ piece.shortCode }}
                                </div>
                            </div>
                        </div>
                    </div>
                    <div v-else-if="!resultadoCorte.error && piezasCalculadas.length > 0 && piezasCalculadas[0].etiqueta !== 'Error'" 
                         class="text-center text-muted fst-italic">
                        No se generaron planos de corte. Verifique las dimensiones.
                    </div>
                </div>

                <!-- Notas e Información -->
                <div class="info-note">
                    <h5 class="fw-bold mb-3"> Notas Importantes y Recomendaciones</h5>
                    <ul class="mb-0">
                        <li class="mb-2">
                            <strong>Método de Construcción:</strong> Este mueble sigue el diseño estándar donde los laterales tienen la altura total, la base y tapa van entre laterales, y las puertas se montan al frente.
                        </li>
                        <li class="mb-2">
                            <strong>Antes de Cortar:</strong> Siempre verifique las medidas calculadas. Esta es una herramienta de estimación y debe validarse manualmente antes de realizar los cortes.
                        </li>
                        <li class="mb-2">
                            <strong>Servicio de Corte:</strong> Muchas madereras en Argentina (Sodimac, Easy, etc.) ofrecen servicio de corte profesional, a veces gratuito para un número limitado de cortes rectos. ¡Consulte antes de comprar!
                        </li>
                        <li class="mb-2">
                            <strong>Ensamblado Profesional:</strong> Use sargentos o prensas para sujetar las piezas antes de atornillar. Realice siempre una perforación guía para evitar que el MDF se raje.
                        </li>
                        <li class="mb-2">
                            <strong>Acabado de Calidad:</strong> Para mejor resultado, aplique una base selladora, lije con lijas progresivas (220→360→600), y use esmalte sintético o acrílico para el acabado final.
                        </li>
                        <li class="mb-2">
                            <strong>Consideración del Kerf:</strong> El ancho de corte configurado afecta el aprovechamiento del material. Un valor típico es 3-4mm para sierras circulares estándar.
                        </li>
                    </ul>
                </div>

                <div class="info-note info-note-warning mt-3">
                    <p class="mb-0">
                        <strong> Descargo de Responsabilidad:</strong> Esta calculadora fue desarrollada como herramienta educativa y de estimación. Los cálculos son aproximaciones y pueden contener errores. 
                        <strong class="text-danger">NO debe usarse como plano profesional sin validación exhaustiva.</strong> El uso es bajo su exclusiva responsabilidad.
                    </p>
                </div>
            </div>
        </div>

        <p class="text-center text-white mt-4 small">
            💻 Desarrollado por smsdev00 | v2.0 Mejorada con IA | Licencia MIT
        </p>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js", "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const { createApp, ref, computed, onMounted, onBeforeUnmount, watch, nextTick, markRaw } = Vue;

        createApp({
            setup() {
                // Estados reactivos
                const largo = ref(80);
                const ancho = ref(40);
                const alto = ref(140);
                const espesor = ref(9);
                const sheetHeight = ref(260);
                const sheetWidth = ref(183);
                const boardPrice = ref(25000);
                const luzPuertas = ref(0.3);
                const kerfWidth = ref(3);
                
                // Estados 3D
                const rendererContainer = ref(null);
                const scene = ref(null);
                const camera = ref(null);
                const renderer = ref(null);
                const controls = ref(null);
                const furnitureGroup = ref(null);
                const isRendererReady = ref(false);
                const renderError = ref(null);
                const doorLeftPivotRef = ref(null);
                const doorRightPivotRef = ref(null);
                const pieceTypeVisibility = ref({
                    Base: true,
                    Tapa: true,
                    Lateral: true,
                    Puerta: true,
                    Trasera: true
                });
                const isDoorLeftOpen = ref(false);
                const isDoorRightOpen = ref(false);
                
                let animationFrameId = null;
                const doorOpenAngle = Math.PI / 1.8;
                
                // Mapas de colores y códigos mejorados
                const colorMap = {
                    'Base': '#dc3545',
                    'Tapa': '#fd7e14',
                    'Lateral': '#ffc107',
                    'Puerta': '#6f42c1',
                    'Trasera': '#0d6efd',
                    'Error': '#6c757d'
                };
                
                const shortCodeMap = {
                    'Base': 'B',
                    'Tapa': 'T',
                    'Lateral': 'L',
                    'Puerta': 'P',
                    'Trasera': 'R',
                    'Error': 'ERR'
                };
                
                // Funciones auxiliares
                const formatDecimal = (value) => typeof value === 'number' ? value.toFixed(1) : value;
                
                const formatCurrency = (value) => {
                    if (typeof value !== 'number' || isNaN(value)) return '$ --.--';
                    return `$ ${value.toLocaleString('es-AR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                };
                
                const getPieceLabel = (type) => {
                    const labels = {
                        'Base': '🟥 Base',
                        'Tapa': '🟧 Tapa',
                        'Lateral': '🟨 Laterales',
                        'Puerta': '🟪 Puertas',
                        'Trasera': '🟦 Trasera'
                    };
                    return labels[type] || type;
                };
                
                // Presets predefinidos
                const loadPreset = (type) => {
                    const presets = {
                        alacena: { largo: 80, ancho: 40, alto: 140, espesor: 15 },
                        biblioteca: { largo: 120, ancho: 30, alto: 180, espesor: 18 },
                        mesita: { largo: 50, ancho: 40, alto: 60, espesor: 15 },
                        placard: { largo: 200, ancho: 60, alto: 240, espesor: 18 }
                    };
                    
                    if (presets[type]) {
                        largo.value = presets[type].largo;
                        ancho.value = presets[type].ancho;
                        alto.value = presets[type].alto;
                        espesor.value = presets[type].espesor;
                    }
                };
                
                // Algoritmo de packing mejorado
                function fitPiezasEnTablas(piezasInput, sheetW, sheetH, kerf) {
                    const hojas = [];
                    let globalPieceIdCounter = 1;
                    const kerfCm = kerf / 10;
                    
                    function crearHoja(id) {
                        return {
                            id: id,
                            ocupados: [],
                            espacios: [{ x: 0, y: 0, w: sheetW, h: sheetH }]
                        };
                    }
                    
                    function puedeColocar(pw, ph, sp) {
                        const wWithKerf = pw + kerfCm;
                        const hWithKerf = ph + kerfCm;
                        const normal = wWithKerf <= sp.w && hWithKerf <= sp.h;
                        const rotated = hWithKerf <= sp.w && wWithKerf <= sp.h;
                        return { cabe: normal || rotated, necesitaRotar: !normal && rotated };
                    }
                    
                    function colocarPiezaEnHoja(hoja, pOrig) {
                        // Ordenar espacios por mejor aprovechamiento
                        hoja.espacios.sort((a, b) => {
                            const areaA = a.w * a.h;
                            const areaB = b.w * b.h;
                            return areaA - areaB;
                        });
                        
                        for (let i = 0; i < hoja.espacios.length; i++) {
                            const sp = hoja.espacios[i];
                            const { cabe, necesitaRotar } = puedeColocar(pOrig.w, pOrig.h, sp);
                            
                            if (cabe) {
                                const rotar = necesitaRotar;
                                const w = rotar ? pOrig.h : pOrig.w;
                                const h = rotar ? pOrig.w : pOrig.h;
                                
                                hoja.ocupados.push({
                                    id: pOrig.id,
                                    x: sp.x,
                                    y: sp.y,
                                    w: w,
                                    h: h,
                                    etiqueta: pOrig.etiqueta,
                                    color: pOrig.color,
                                    shortCode: pOrig.shortCode,
                                    originalDim1: pOrig.originalDim1,
                                    originalDim2: pOrig.originalDim2
                                });
                                
                                hoja.espacios.splice(i, 1);
                                
                                const kerfCm = pOrig.kerf / 10;
                                const remainW = sp.w - w - kerfCm;
                                const remainH = sp.h - h - kerfCm;
                                
                                if (remainW > 0.1) {
                                    hoja.espacios.push({
                                        x: sp.x + w + kerfCm,
                                        y: sp.y,
                                        w: remainW,
                                        h: h
                                    });
                                }
                                
                                if (remainH > 0.1) {
                                    hoja.espacios.push({
                                        x: sp.x,
                                        y: sp.y + h + kerfCm,
                                        w: sp.w,
                                        h: remainH
                                    });
                                }
                                
                                return true;
                            }
                        }
                        return false;
                    }
                    
                    let todas = [];
                    for (const pIn of piezasInput) {
                        const pw = pIn.dim1;
                        const ph = pIn.dim2;
                        const kerfCm = kerf / 10;
                        
                        if (!((pw + kerfCm <= sheetH && ph + kerfCm <= sheetW) || 
                              (pw + kerfCm <= sheetW && ph + kerfCm <= sheetH))) {
                            throw new Error(`Pieza ${pIn.etiqueta} (${formatDecimal(pw)}x${formatDecimal(ph)}) no cabe en la placa.`);
                        }
                        
                        for (let i = 0; i < pIn.cantidad; i++) {
                            todas.push({
                                id: globalPieceIdCounter++,
                                w: pw,
                                h: ph,
                                area: pw * ph,
                                etiqueta: pIn.etiqueta,
                                color: pIn.color,
                                shortCode: pIn.shortCode,
                                originalDim1: pw,
                                originalDim2: ph,
                                kerf: kerf
                            });
                        }
                    }
                    
                    // Ordenar por área descendente (piezas más grandes primero)
                    todas.sort((a, b) => b.area - a.area);
                    
                    for (const p of todas) {
                        let colocada = false;
                        
                        for (const h of hojas) {
                            if (colocarPiezaEnHoja(h, p)) {
                                colocada = true;
                                break;
                            }
                        }
                        
                        if (!colocada) {
                            const nH = crearHoja(hojas.length + 1);
                            if (colocarPiezaEnHoja(nH, p)) {
                                hojas.push(nH);
                            } else {
                                throw new Error(`No se pudo colocar pieza ${p.etiqueta}`);
                            }
                        }
                    }
                    
                    return hojas;
                }
                
                // Cálculo de piezas
                const piezasCalculadas = computed(() => {
                    const L = parseFloat(largo.value);
                    const A = parseFloat(ancho.value);
                    const H = parseFloat(alto.value);
                    const E_mm = parseFloat(espesor.value);
                    const luz = parseFloat(luzPuertas.value);
                    
                    if (isNaN(L) || isNaN(A) || isNaN(H) || isNaN(E_mm) || 
                        L <= 0 || A <= 0 || H <= 0 || E_mm <= 0 || isNaN(luz) || luz < 0) {
                        return [];
                    }
                    
                    const E_cm = E_mm / 10;
                    
                    if (L <= 2 * E_cm) {
                        return [{
                            etiqueta: 'Error',
                            cantidad: '-',
                            dim1: 'Largo insuficiente para el espesor seleccionado',
                            dim2: '-',
                            nota: 'Ajuste medidas',
                            color: colorMap['Error'],
                            shortCode: shortCodeMap['Error']
                        }];
                    }
                    
                    if (H <= 2 * E_cm) {
                        return [{
                            etiqueta: 'Error',
                            cantidad: '-',
                            dim1: 'Alto insuficiente para el espesor seleccionado',
                            dim2: '-',
                            nota: 'Ajuste medidas',
                            color: colorMap['Error'],
                            shortCode: shortCodeMap['Error']
                        }];
                    }
                    
                    const anchoTotalFrente = L - (2 * E_cm);
                    const anchoDisponibleParaPuertas = anchoTotalFrente - luz;
                    const anchoPuerta = anchoDisponibleParaPuertas / 2;
                    
                    if (anchoPuerta <= 0.1) {
                        return [{
                            etiqueta: 'Error',
                            cantidad: '-',
                            dim1: 'Ancho de puertas insuficiente',
                            dim2: '-',
                            nota: 'Ajuste Largo, Espesor o Separación',
                            color: colorMap['Error'],
                            shortCode: shortCodeMap['Error']
                        }];
                    }
                    
                    const piezasBase = [
                        { etiqueta: 'Base', cantidad: 1, dim1: L, dim2: A, nota: 'Pieza inferior' },
                        { etiqueta: 'Tapa', cantidad: 1, dim1: L, dim2: A, nota: 'Pieza superior' },
                        { etiqueta: 'Lateral', cantidad: 2, dim1: H, dim2: A, nota: 'Caras laterales' },
                        { etiqueta: 'Puerta', cantidad: 2, dim1: H, dim2: anchoPuerta, nota: `Frontal (${formatDecimal(luz)}cm separación)` },
                        { etiqueta: 'Trasera', cantidad: 1, dim1: H, dim2: L - (2 * E_cm), nota: 'Posterior (entre laterales)' }
                    ];
                    
                    return piezasBase
                        .filter(p => p.dim1 > 0.1 && p.dim2 > 0.1)
                        .map(p => ({
                            ...p,
                            color: colorMap[p.etiqueta] || '#6c757d',
                            shortCode: shortCodeMap[p.etiqueta] || '?'
                        }));
                });
                
                // Cálculo de resultados de corte
                const resultadoCorte = computed(() => {
                    const piezas = piezasCalculadas.value;
                    const sh = parseFloat(sheetHeight.value);
                    const sw = parseFloat(sheetWidth.value);
                    const price = parseFloat(boardPrice.value);
                    const kerf = parseFloat(kerfWidth.value);
                    
                    const defaultResult = {
                        count: -1,
                        totalPrice: 0,
                        boardData: [],
                        error: null
                    };
                    
                    if (!piezas || piezas.length === 0) {
                        defaultResult.error = "Ingrese dimensiones válidas.";
                        return defaultResult;
                    }
                    
                    if (piezas[0].etiqueta === 'Error') {
                        defaultResult.error = piezas[0].dim1;
                        return defaultResult;
                    }
                    
                    if (isNaN(sh) || isNaN(sw) || sh <= 0 || sw <= 0) {
                        defaultResult.error = "Dimensiones de placa inválidas.";
                        return defaultResult;
                    }
                    
                    if (isNaN(price) || price < 0) {
                        defaultResult.error = "Precio por placa inválido.";
                        return defaultResult;
                    }
                    
                    try {
                        const hojasCalculadas = fitPiezasEnTablas(piezas, sw, sh, kerf);
                        const numSheets = hojasCalculadas.length;
                        const totalPrice = numSheets * price;
                        
                        const boardData = hojasCalculadas.map(hoja => ({
                            id: hoja.id,
                            pieces: hoja.ocupados.map(p => ({
                                id: p.id,
                                etiqueta: p.etiqueta,
                                color: p.color,
                                shortCode: p.shortCode,
                                originalDim1: p.originalDim1,
                                originalDim2: p.originalDim2,
                                x: p.x,
                                y: p.y,
                                w: p.w,
                                h: p.h
                            }))
                        }));
                        
                        return {
                            count: numSheets,
                            totalPrice: totalPrice,
                            boardData: boardData,
                            error: null
                        };
                    } catch (error) {
                        console.error("Error en el packing:", error);
                        defaultResult.error = error.message || "Error en cálculo de corte.";
                        defaultResult.count = 0;
                        defaultResult.boardData = [];
                        return defaultResult;
                    }
                });
                
                // Cálculos de eficiencia
                const totalPiecesArea = computed(() => {
                    return piezasCalculadas.value.reduce((sum, p) => {
                        if (p.etiqueta === 'Error') return sum;
                        return sum + (p.dim1 * p.dim2 * p.cantidad);
                    }, 0);
                });
                
                const totalBoardsArea = computed(() => {
                    return resultadoCorte.value.count * sheetHeight.value * sheetWidth.value;
                });
                
                const wasteArea = computed(() => {
                    return totalBoardsArea.value - totalPiecesArea.value;
                });
                
                const efficiency = computed(() => {
                    if (totalBoardsArea.value === 0) return 0;
                    return Math.min(100, Math.max(0, (totalPiecesArea.value / totalBoardsArea.value * 100).toFixed(1)));
                });
                
                // Funciones para estilos de piezas
                const getPieceStyle = (piece, currentSheetW, currentSheetH) => {
                    const safeSheetW = currentSheetW > 0 ? currentSheetW : 1;
                    const safeSheetH = currentSheetH > 0 ? currentSheetH : 1;
                    const widthPerc = Math.max((piece.w / safeSheetW) * 100, 0.1);
                    const heightPerc = Math.max((piece.h / safeSheetH) * 100, 0.1);
                    
                    return {
                        position: 'absolute',
                        left: (piece.x / safeSheetW) * 100 + '%',
                        top: (piece.y / safeSheetH) * 100 + '%',
                        width: widthPerc + '%',
                        height: heightPerc + '%',
                        backgroundColor: piece.color
                    };
                };
                
                const getPieceTooltip = (piece) => {
                    return `${piece.etiqueta}\n` +
                           `Dimensiones: ${formatDecimal(piece.originalDim1)} × ${formatDecimal(piece.originalDim2)} cm\n` +
                           `Posición: (${formatDecimal(piece.x)}, ${formatDecimal(piece.y)})\n` +
                           `Colocada: ${formatDecimal(piece.w)} × ${formatDecimal(piece.h)} cm\n` +
                           `ID: ${piece.id}`;
                };
                
                // Controles de puertas
                const toggleDoorLeft = () => {
                    isDoorLeftOpen.value = !isDoorLeftOpen.value;
                };
                
                const toggleDoorRight = () => {
                    isDoorRightOpen.value = !isDoorRightOpen.value;
                };
                
                // Función para ajustar cámara
                function fitCameraToObject(camera, object, controls, offset = 1.5) {
                    const boundingBox = new THREE.Box3();
                    boundingBox.setFromObject(object);
                    
                    const center = new THREE.Vector3();
                    boundingBox.getCenter(center);
                    
                    const size = new THREE.Vector3();
                    boundingBox.getSize(size);
                    
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                    cameraZ *= offset;
                    
                    camera.position.x = center.x + cameraZ * 0.7;
                    camera.position.y = center.y + cameraZ * 0.5;
                    camera.position.z = center.z + cameraZ;
                    
                    const minZ = boundingBox.min.z;
                    const cameraToFarEdge = (minZ < 0) ? -minZ + cameraZ : cameraZ - minZ;
                    camera.far = cameraToFarEdge * 3;
                    camera.updateProjectionMatrix();
                    
                    if (controls) {
                        controls.target.copy(center);
                        controls.saveState();
                        controls.update();
                    }
                }
                
                function onWindowResize() {
                    if (!camera.value || !renderer.value || !rendererContainer.value) return;
                    const container = rendererContainer.value;
                    camera.value.aspect = container.clientWidth / container.clientHeight;
                    camera.value.updateProjectionMatrix();
                    renderer.value.setSize(container.clientWidth, container.clientHeight);
                }
                
                const resetCamera = () => {
                    if (furnitureGroup.value && camera.value && controls.value) {
                        fitCameraToObject(camera.value, furnitureGroup.value, controls.value);
                    }
                };
                
                // Inicialización Three.js
                function initThreeJS() {
                    if (!rendererContainer.value || !THREE) return;
                    
                    try {
                        const _scene = new THREE.Scene();
                        _scene.background = new THREE.Color(0x1e293b);
                        scene.value = markRaw(_scene);
                        
                        const container = rendererContainer.value;
                        const aspect = container.clientWidth / container.clientHeight;
                        const _camera = new THREE.PerspectiveCamera(50, aspect, 1, 2000);
                        _camera.position.set(100, 100, 150);
                        camera.value = markRaw(_camera);
                        
                        scene.value.add(new THREE.AmbientLight(0xffffff, 0.7));
                        const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
                        dirLight.position.set(0.5, 1, 1);
                        scene.value.add(dirLight);
                        
                        const _renderer = new THREE.WebGLRenderer({ antialias: true });
                        _renderer.setSize(container.clientWidth, container.clientHeight);
                        _renderer.setPixelRatio(window.devicePixelRatio);
                        renderer.value = markRaw(_renderer);
                        container.appendChild(renderer.value.domElement);
                        
                        const _controls = new OrbitControls(camera.value, renderer.value.domElement);
                        _controls.enableDamping = true;
                        _controls.dampingFactor = 0.1;
                        _controls.screenSpacePanning = false;
                        controls.value = markRaw(_controls);
                        
                        const _furnitureGroup = new THREE.Group();
                        furnitureGroup.value = markRaw(_furnitureGroup);
                        scene.value.add(furnitureGroup.value);
                        
                        animate();
                        isRendererReady.value = true;
                        renderError.value = null;
                        window.addEventListener('resize', onWindowResize);
                    } catch (error) {
                        console.error("Error inicializando Three.js:", error);
                        renderError.value = "No se pudo iniciar el visor 3D.";
                        isRendererReady.value = false;
                    }
                }
                
                function animate() {
                    if (!renderer.value || !scene.value || !camera.value) return;
                    animationFrameId = requestAnimationFrame(animate);
                    controls.value.update();
                    
                    const targetRotLeft = isDoorLeftOpen.value ? -doorOpenAngle : 0;
                    const targetRotRight = isDoorRightOpen.value ? doorOpenAngle : 0;
                    const lerpFactor = 0.1;
                    
                    if (doorLeftPivotRef.value) {
                        doorLeftPivotRef.value.rotation.y = THREE.MathUtils.lerp(
                            doorLeftPivotRef.value.rotation.y,
                            targetRotLeft,
                            lerpFactor
                        );
                    }
                    
                    if (doorRightPivotRef.value) {
                        doorRightPivotRef.value.rotation.y = THREE.MathUtils.lerp(
                            doorRightPivotRef.value.rotation.y,
                            targetRotRight,
                            lerpFactor
                        );
                    }
                    
                    renderer.value.render(scene.value, camera.value);
                }
                
                // Actualización del modelo 3D
                function updateFurnitureModel() {
                    if (!isRendererReady.value || !furnitureGroup.value) return;
                    
                    while (furnitureGroup.value.children.length > 0) {
                        const object = furnitureGroup.value.children[0];
                        if (object instanceof THREE.Mesh && object.geometry) {
                            object.geometry.dispose();
                        }
                        furnitureGroup.value.remove(object);
                    }
                    
                    doorLeftPivotRef.value = null;
                    doorRightPivotRef.value = null;
                    renderError.value = null;
                    
                    const L = parseFloat(largo.value);
                    const A = parseFloat(ancho.value);
                    const H = parseFloat(alto.value);
                    const E_mm = parseFloat(espesor.value);
                    const luz = parseFloat(luzPuertas.value);
                    
                    if (isNaN(L) || isNaN(A) || isNaN(H) || isNaN(E_mm) || 
                        L <= 0 || A <= 0 || H <= 0 || E_mm <= 0 || isNaN(luz) || luz < 0) {
                        renderError.value = "Dimensiones inválidas.";
                        return;
                    }
                    
                    const E_cm = E_mm / 10;
                    
                    if (L <= 2 * E_cm || H <= 2 * E_cm) {
                        renderError.value = "Dimensiones insuficientes.";
                        return;
                    }
                    
                    const anchoTotalFrente = L - (2 * E_cm);
                    const anchoDisponibleParaPuertas = anchoTotalFrente - luz;
                    const anchoPuerta = anchoDisponibleParaPuertas / 2;
                    
                    if (anchoPuerta <= 0.1) {
                        renderError.value = "Ancho puertas insuficiente.";
                        return;
                    }
                    
                    try {
                        const materials = {};
                        for (const key in colorMap) {
                            materials[key] = new THREE.MeshStandardMaterial({
                                color: colorMap[key],
                                roughness: 0.7,
                                metalness: 0.2,
                                side: THREE.DoubleSide
                            });
                        }
                        
                        const addMesh = (pieceType, geometry, position) => {
                            const material = materials[pieceType] || materials['Error'];
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.position.copy(position);
                            mesh.userData.pieceType = pieceType;
                            mesh.visible = pieceTypeVisibility.value[pieceType];
                            furnitureGroup.value.add(mesh);
                            return mesh;
                        };
                        
                        // Base
                        const baseGeo = new THREE.BoxGeometry(L, E_cm, A);
                        addMesh('Base', baseGeo, new THREE.Vector3(0, E_cm / 2, 0));
                        
                        // Tapa
                        const tapaGeo = new THREE.BoxGeometry(L, E_cm, A);
                        addMesh('Tapa', tapaGeo, new THREE.Vector3(0, H - E_cm / 2, 0));
                        
                        // Laterales
                        const latGeo = new THREE.BoxGeometry(E_cm, H, A);
                        addMesh('Lateral', latGeo, new THREE.Vector3(-L / 2 + E_cm / 2, H / 2, 0));
                        addMesh('Lateral', latGeo.clone(), new THREE.Vector3(L / 2 - E_cm / 2, H / 2, 0));
                        
                        // Trasera
                        const traseraW = L - 2 * E_cm;
                        if (traseraW > 0.1) {
                            const traseraGeo = new THREE.BoxGeometry(traseraW, H, E_cm);
                            addMesh('Trasera', traseraGeo, new THREE.Vector3(0, H / 2, -A / 2 + E_cm / 2));
                        }
                        
                        // Puertas con pivotes
                        const puertaGeo = new THREE.BoxGeometry(anchoPuerta, H, E_cm);
                        
                        const pivotLeft = new THREE.Group();
                        pivotLeft.position.set(-L / 2 + E_cm / 2, H / 2, A / 2 - E_cm / 2);
                        const puertaIzqMesh = new THREE.Mesh(puertaGeo, materials['Puerta']);
                        puertaIzqMesh.position.set(anchoPuerta / 2, 0, 0);
                        pivotLeft.add(puertaIzqMesh);
                        pivotLeft.userData.pieceType = 'Puerta';
                        pivotLeft.visible = pieceTypeVisibility.value['Puerta'];
                        furnitureGroup.value.add(pivotLeft);
                        doorLeftPivotRef.value = markRaw(pivotLeft);
                        
                        const pivotRight = new THREE.Group();
                        pivotRight.position.set(L / 2 - E_cm / 2, H / 2, A / 2 - E_cm / 2);
                        const puertaDerMesh = new THREE.Mesh(puertaGeo.clone(), materials['Puerta']);
                        puertaDerMesh.position.set(-anchoPuerta / 2, 0, 0);
                        pivotRight.add(puertaDerMesh);
                        pivotRight.userData.pieceType = 'Puerta';
                        pivotRight.visible = pieceTypeVisibility.value['Puerta'];
                        furnitureGroup.value.add(pivotRight);
                        doorRightPivotRef.value = markRaw(pivotRight);
                        
                        // Aplicar rotaciones iniciales
                        if (pivotLeft.visible) {
                            pivotLeft.rotation.y = isDoorLeftOpen.value ? -doorOpenAngle : 0;
                        } else {
                            pivotLeft.rotation.y = 0;
                        }
                        
                        if (pivotRight.visible) {
                            pivotRight.rotation.y = isDoorRightOpen.value ? doorOpenAngle : 0;
                        } else {
                            pivotRight.rotation.y = 0;
                        }
                        
                        fitCameraToObject(camera.value, furnitureGroup.value, controls.value);
                    } catch (error) {
                        console.error("Error al generar piezas 3D:", error);
                        renderError.value = "Error al generar piezas 3D.";
                        while (furnitureGroup.value.children.length > 0) {
                            furnitureGroup.value.remove(furnitureGroup.value.children[0]);
                        }
                        doorLeftPivotRef.value = null;
                        doorRightPivotRef.value = null;
                    }
                }
                
                // Hooks de ciclo de vida
                onMounted(() => {
                    nextTick(() => {
                        initThreeJS();
                        if (isRendererReady.value) {
                            updateFurnitureModel();
                        }
                    });
                });
                
                onBeforeUnmount(() => {
                    cancelAnimationFrame(animationFrameId);
                    window.removeEventListener('resize', onWindowResize);
                    
                    if (renderer.value) {
                        if (scene.value) {
                            scene.value.traverse(object => {
                                if (object.geometry) object.geometry.dispose();
                                if (object.material) {
                                    if (Array.isArray(object.material)) {
                                        object.material.forEach(material => material.dispose());
                                    } else {
                                        object.material.dispose();
                                    }
                                }
                            });
                        }
                        renderer.value.dispose();
                        if (rendererContainer.value && renderer.value.domElement) {
                            rendererContainer.value.removeChild(renderer.value.domElement);
                        }
                    }
                    
                    if (controls.value) {
                        controls.value.dispose();
                    }
                    
                    isRendererReady.value = false;
                    doorLeftPivotRef.value = null;
                    doorRightPivotRef.value = null;
                });
                
                // Watchers optimizados
                watch([largo, ancho, alto, espesor, luzPuertas], () => {
                    if (isRendererReady.value) {
                        updateFurnitureModel();
                    }
                }, { immediate: false });
                
                watch(pieceTypeVisibility, (newVisibility) => {
                    if (!isRendererReady.value || !furnitureGroup.value) return;
                    
                    furnitureGroup.value.children.forEach(child => {
                        const pieceType = child.userData.pieceType;
                        if (pieceType && newVisibility.hasOwnProperty(pieceType)) {
                            const shouldBeVisible = newVisibility[pieceType];
                            
                            if (child.visible !== shouldBeVisible) {
                                child.visible = shouldBeVisible;
                                
                                if (pieceType === 'Puerta' && !shouldBeVisible) {
                                    if (child === doorLeftPivotRef.value || child === doorRightPivotRef.value) {
                                        child.rotation.y = 0;
                                    }
                                }
                            }
                        }
                    });
                }, { deep: true, flush: 'post' });
                
                // Retornar valores para el template
                return {
                    // Estados de entrada
                    largo,
                    ancho,
                    alto,
                    espesor,
                    sheetHeight,
                    sheetWidth,
                    boardPrice,
                    luzPuertas,
                    kerfWidth,
                    
                    // Estados 3D
                    rendererContainer,
                    isRendererReady,
                    renderError,
                    pieceTypeVisibility,
                    isDoorLeftOpen,
                    isDoorRightOpen,
                    
                    // Datos computados
                    piezasCalculadas,
                    resultadoCorte,
                    totalPiecesArea,
                    totalBoardsArea,
                    wasteArea,
                    efficiency,
                    
                    // Funciones
                    formatDecimal,
                    formatCurrency,
                    getPieceStyle,
                    getPieceTooltip,
                    getPieceLabel,
                    toggleDoorLeft,
                    toggleDoorRight,
                    resetCamera,
                    loadPreset
                };
            }
        }).mount('#app');
    </script>
</body>
</html>