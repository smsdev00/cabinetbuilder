<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Mueble - Plano de Corte v1.2</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        #app {
            max-width: 1100px;
        }
        .table th, .table td {
            vertical-align: middle;
        }
        .card {
            margin-bottom: 1.5rem;
        }
        .resultado-tablas, .resultado-precio {
            font-size: 1.2rem;
            font-weight: bold;
            margin-right: 15px;
        }
        .construction-note {
            font-size: 0.9rem;
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid #0d6efd;
            margin-bottom: 1.5rem;
        }
        /* --- Estilos Plano de Corte --- */
        .sheet-layout-container {
            position: relative;
            border: 2px solid #343a40;
            background-color: #fdfdfd;
            width: 100%;
            max-width: 500px;
            margin: 0 auto 15px auto;
            overflow: hidden;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
        }
        .placed-piece {
            position: absolute;
            border: 1px solid rgba(0, 0, 0, 0.7);
            box-sizing: border-box;
            overflow: hidden;
            min-width: 1px;
            min-height: 1px;
            /* ** CSS para centrar texto ** */
            display: flex;
            align-items: center;
            justify-content: center;
            /* ** Estilos del texto ** */
            color: white;
            font-size: 0.7rem; /* Ajustar según necesidad */
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            text-align: center; /* Fallback */
            line-height: 1; /* Ajustar si el texto se corta verticalmente */
            user-select: none; /* Evitar seleccionar el texto accidentalmente */
        }
         .board-header {
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
         }
         .piece-tooltip-content {
            white-space: pre;
         }

    </style>
</head>
<body>
    <div id="app" class="container mt-4 mb-5">
        <h1 class="mb-4 text-center">Calculadora de Mueble - Plano de Corte Estimado v1.2</h1>

        <div class="row">
             <div class="col-lg-6">
                 <div class="card shadow-sm h-100">
                     <div class="card-header">1. Dimensiones del Mueble y Material</div>
                     <div class="card-body"><div class="row g-3">
                            <div class="col-md-6"><label for="largo" class="form-label">Largo Base (cm):</label><input type="number" id="largo" class="form-control" v-model.number="largo" min="1"></div>
                            <div class="col-md-6"><label for="ancho" class="form-label">Ancho Base (cm):</label><input type="number" id="ancho" class="form-control" v-model.number="ancho" min="1"></div>
                            <div class="col-md-6"><label for="alto" class="form-label">Alto Total (cm):</label><input type="number" id="alto" class="form-control" v-model.number="alto" min="1"></div>
                            <div class="col-md-6"><label for="espesor" class="form-label">Espesor Material (mm):</label><input type="number" id="espesor" class="form-control" v-model.number="espesor" min="1" step="0.1"></div>
                        </div>
                     </div>
                 </div>
             </div>
             <div class="col-lg-6">
                 <div class="card shadow-sm h-100">
                     <div class="card-header">2. Datos de la Tabla de MDF</div>
                     <div class="card-body"><div class="row g-3">
                            <div class="col-md-6"><label for="sheetHeight" class="form-label">Alto Tabla (cm):</label><input type="number" id="sheetHeight" class="form-control" v-model.number="sheetHeight" min="1"></div>
                            <div class="col-md-6"><label for="sheetWidth" class="form-label">Ancho Tabla (cm):</label><input type="number" id="sheetWidth" class="form-control" v-model.number="sheetWidth" min="1"></div>
                            <div class="col-12"><label for="boardPrice" class="form-label">Precio por Tabla ($):</label><input type="number" id="boardPrice" class="form-control" v-model.number="boardPrice" min="0" step="any"></div>
                        </div>
                     </div>
                 </div>
             </div>
        </div>

        <div class="card shadow-sm mt-4">
            <div class="card-header">
                3. Resultados del Cálculo
            </div>
            <div class="card-body">
                <div class="text-center mb-4 p-3 bg-light rounded border">
                     <span class="resultado-tablas">Tablas MDF: {{ resultadoCorte.count >= 0 ? resultadoCorte.count : 'N/A' }}</span>
                     <span class="resultado-precio">Costo Total: {{ formatCurrency(resultadoCorte.totalPrice) }}</span>
                     <p v-if="resultadoCorte.count > 0 && !resultadoCorte.error" class="text-muted small mt-2 mb-0">Estimación con packer simplificado. El layout real y costo pueden variar.</p>
                     <p v-if="resultadoCorte.error" class="text-danger small mt-2 mb-0"><strong>Error:</strong> {{ resultadoCorte.error }}</p>
                 </div>

                 <div class="construction-note">
                     <p class="mb-1 fw-bold">Método de Construcción Asumido:</p>
                     <ul class="mb-0" style="padding-left: 1.2em;">
                         <li>Laterales: Cubren Alto y Ancho (profundidad) total.</li>
                         <li>Base/Tapa: Cubren Largo y Ancho (profundidad) total externo.</li>
                         <li>Frente/Trasera: Tienen Alto total, pero encajan <strong>entre</strong> los laterales (Ancho = Largo - 2*Espesor).</li>
                     </ul>
                 </div>

                <h3 class="fs-5 mt-4 mb-3 text-center">Despiece Detallado del Mueble</h3>
                 <div class="table-responsive mb-4">
                     <table class="table table-striped table-bordered table-hover table-sm">
                         <thead class="table-dark"><tr><th>Etiqueta</th><th>Cód.</th><th>Cantidad</th><th>Medida 1 (cm)</th><th>Medida 2 (cm)</th><th>Color Ref.</th><th>Notas</th></tr></thead>
                         <tbody>
                             <tr v-if="piezasCalculadas.length === 0 || piezasCalculadas[0].etiqueta === 'Error'"><td colspan="7" class="text-center fst-italic">{{ piezasCalculadas.length > 0 ? piezasCalculadas[0].dim1 : 'Ingrese dimensiones válidas.' }}</td></tr>
                             <tr v-else v-for="pieza in piezasCalculadas" :key="pieza.etiqueta + pieza.dim1">
                                <td :style="{borderLeft: `5px solid ${pieza.color}`}">{{ pieza.etiqueta }}</td>
                                <td class="fw-bold">{{ pieza.shortCode }}</td> <td>{{ pieza.cantidad }}</td>
                                <td>{{ formatDecimal(pieza.dim1) }}</td>
                                <td>{{ formatDecimal(pieza.dim2) }}</td>
                                <td><span :style="{ backgroundColor: pieza.color, padding: '2px 8px', borderRadius: '3px' }">&nbsp;</span></td>
                                <td>{{ pieza.nota || '-' }}</td>
                             </tr>
                         </tbody>
                     </table>
                 </div>

                <h3 class="fs-4 mt-5 mb-4 text-center">Planos de Corte Estimados</h3>
                  <p v-if="resultadoCorte.count > 0 && !resultadoCorte.error" class="text-center text-muted small mb-4">
                      Representación visual basada en el packer simplificado. NO considera ancho de corte (kerf).
                  </p>
                 <div v-if="resultadoCorte.boardData && resultadoCorte.boardData.length > 0 && !resultadoCorte.error" class="row">
                    <div v-for="board in resultadoCorte.boardData" :key="board.id" class="col-lg-6 mb-4">
                        <div class="board-header">Tabla #{{ board.id }}</div>
                        <div class="sheet-layout-container"
                             :style="{ aspectRatio: (currentSheetWidth > 0 ? currentSheetWidth : 1) / (currentSheetHeight > 0 ? currentSheetHeight : 1) }">
                             <div v-for="piece in board.pieces"
                                  :key="piece.id"
                                  class="placed-piece"
                                  :style="getPieceStyle(piece, currentSheetWidth, currentSheetHeight)"
                                  :title="getPieceTooltip(piece)">
                                  {{ piece.shortCode }}
                             </div>
                        </div>
                    </div>
                 </div>
                 <div v-else-if="!resultadoCorte.error && piezasCalculadas.length > 0 && piezasCalculadas[0].etiqueta !== 'Error'" class="text-center text-muted fst-italic">
                    No se generaron planos de corte. Verifique dimensiones/errores.
                 </div>
                 </div> </div> <p class="text-center text-muted mt-4 small">
            {{ currentDateTime }}
        </p>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

    <script>
        const { createApp, ref, computed } = Vue;

        createApp({
            setup() {
                // --- Estado Reactivo ---
                const largo = ref(80); const ancho = ref(80); const alto = ref(160);
                const espesor = ref(9); const sheetHeight = ref(260); const sheetWidth = ref(183);
                const boardPrice = ref(25000); const currentDateTime = ref('');

                const updateDateTime = () => { /* ... igual ... */
                     currentDateTime.value = new Date().toLocaleString('es-AR', { timeZone: 'America/Argentina/Buenos_Aires', dateStyle: 'long', timeStyle: 'medium' });
                 };
                updateDateTime();

                // --- Mapeos ---
                const colorMap = { /* ... igual ... */
                     'Base': '#dc3545', 'Tapa': '#fd7e14', 'Lateral': '#ffc107',
                     'Frente': '#20c997', 'Trasera': '#0d6efd', 'Error': '#6c757d'
                 };
                // *** NUEVO MAPEO DE CÓDIGOS CORTOS ***
                const shortCodeMap = {
                    'Base': 'B',
                    'Tapa': 'T',
                    'Lateral': 'L',
                    'Frente': 'F',
                    'Trasera': 'R', // 'R' for Rear
                    'Error': 'ERR'
                };

                // --- Funciones Auxiliares ---
                const formatDecimal = (value) => typeof value === 'number' ? value.toFixed(1) : value;
                const formatCurrency = (value) => { /* ... igual ... */
                     if (typeof value !== 'number' || isNaN(value)) return '$ --.--';
                     return `$ ${value.toLocaleString('es-AR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                 };

                // --- Función de Packing (SIN CAMBIOS EN SU LÓGICA INTERNA) ---
                // La función fitPiezasEnTablas es la misma que antes. Solo necesita que
                // la pieza que recibe en `colocarPiezaEnHoja` tenga la propiedad `shortCode`.
                 function fitPiezasEnTablas(piezasInput, sheetWidth, sheetHeight) { /* ... código interno igual ... */
                     const hojas = []; let globalPieceIdCounter = 1;
                     function crearHoja(id){ return { id: id, ocupados: [], espacios: [{ x: 0, y: 0, w: sheetWidth, h: sheetHeight }] }; }
                     function puedeColocar(pw, ph, sp){ const cn=pw<=sp.w&&ph<=sp.h; const cr=ph<=sp.w&&pw<=sp.h; return {cabe:cn||cr, necesitaRotar:!cn&&cr}; }
                     function colocarPiezaEnHoja(hoja, pOrig){ // pOrig ahora tendrá 'shortCode'
                         let mejorIdx=-1, rotar=false;
                         for(let i=0; i<hoja.espacios.length; i++){ const sp=hoja.espacios[i]; const {cabe,necesitaRotar}=puedeColocar(pOrig.w,pOrig.h,sp); if(cabe){mejorIdx=i; rotar=necesitaRotar; break;}}
                         if(mejorIdx!==-1){
                             const sp=hoja.espacios[mejorIdx]; const rt=rotar; const w=rt?pOrig.h:pOrig.w; const h=rt?pOrig.w:pOrig.h;
                             // Añadir shortCode al objeto guardado en 'ocupados'
                             hoja.ocupados.push({
                                id: pOrig.id, x: sp.x, y: sp.y, w: w, h: h,
                                etiqueta: pOrig.etiqueta, color: pOrig.color, shortCode: pOrig.shortCode, // <-- Añadido
                                originalDim1: pOrig.originalDim1, originalDim2: pOrig.originalDim2
                             });
                             hoja.espacios.splice(mejorIdx,1);
                             if(sp.w-w>0.1) hoja.espacios.push({x:sp.x+w, y:sp.y, w:sp.w-w, h:sp.h});
                             if(sp.h-h>0.1) hoja.espacios.push({x:sp.x, y:sp.y+h, w:w, h:sp.h-h});
                             return true;
                         } return false;
                     }
                     let todas=[];
                     for(const pIn of piezasInput){ const pw=pIn.dim1; const ph=pIn.dim2; if(!((pw<=sheetHeight&&ph<=sheetWidth)||(pw<=sheetWidth&&ph<=sheetHeight))) throw new Error(`Pieza ${pIn.etiqueta} (${formatDecimal(pw)}x${formatDecimal(ph)}) no cabe.`); for(let i=0; i<pIn.cantidad; i++) todas.push({
                         id:globalPieceIdCounter++, w:pw, h:ph, area:pw*ph,
                         etiqueta:pIn.etiqueta, color:pIn.color, shortCode: pIn.shortCode, // <-- Añadido aquí también
                         originalDim1:pw, originalDim2:ph
                         });
                     }
                     todas.sort((a,b)=>b.area-a.area);
                     for(const p of todas){ let colocada=false; for(const h of hojas){if(colocarPiezaEnHoja(h,p)){colocada=true; break;}} if(!colocada){const nH=crearHoja(hojas.length+1); if(colocarPiezaEnHoja(nH,p)) hojas.push(nH); else throw new Error(`Error al colocar ${p.etiqueta} en hoja nueva.`);}}
                     return hojas;
                 }


                // --- Propiedades Calculadas ---
                const piezasCalculadas = computed(() => { /* Modificado para añadir shortCode */
                    const L = parseFloat(largo.value); const A = parseFloat(ancho.value);
                    const H = parseFloat(alto.value); const E_mm = parseFloat(espesor.value);
                    // ... validaciones ...
                     if (isNaN(L) || isNaN(A) || isNaN(H) || isNaN(E_mm) || L <= 0 || A <= 0 || H <= 0 || E_mm <= 0) return [];
                     const E_cm = E_mm / 10;
                     if (L <= 2 * E_cm) return [{ etiqueta: 'Error', cantidad: '-', dim1: 'Largo insuficiente', nota: 'Ajuste medidas', color: colorMap['Error'], shortCode: shortCodeMap['Error'] }];
                     // ... más validaciones con shortCode ...

                    const piezasBase = [ /* ...definición piezas... */
                        { etiqueta: 'Base', cantidad: 1, dim1: L, dim2: A, nota: 'Pieza inferior' },
                        { etiqueta: 'Tapa', cantidad: 1, dim1: L, dim2: A, nota: 'Pieza superior' },
                        { etiqueta: 'Lateral', cantidad: 2, dim1: H, dim2: A, nota: 'Caras laterales' },
                        { etiqueta: 'Frente', cantidad: 1, dim1: H, dim2: L - (2 * E_cm), nota: 'Frontal (entre laterales)' },
                        { etiqueta: 'Trasera', cantidad: 1, dim1: H, dim2: L - (2 * E_cm), nota: 'Posterior (entre laterales)' }
                    ];

                    return piezasBase
                        .filter(p => p.dim1 > 0.1 && p.dim2 > 0.1)
                        .map(p => ({
                            ...p,
                            color: colorMap[p.etiqueta] || '#6c757d',
                            shortCode: shortCodeMap[p.etiqueta] || '?' // Añadir código corto
                        }));
                });

                const resultadoCorte = computed(() => { /* Modificado para pasar shortCode y mapearlo */
                    const piezas = piezasCalculadas.value; // Ahora tienen shortCode
                    const sh = parseFloat(sheetHeight.value); const sw = parseFloat(sheetWidth.value); const price = parseFloat(boardPrice.value);
                    const defaultResult = { count: 0, totalPrice: 0, boardData: [], error: null };
                    // ... validaciones ...
                     if (!piezas || piezas.length === 0 || piezas[0].etiqueta === 'Error') { defaultResult.error="..."; return defaultResult; }
                     if (isNaN(sh) || isNaN(sw) || sh <= 0 || sw <= 0) { defaultResult.error="..."; return defaultResult; }
                     if (isNaN(price) || price < 0) { defaultResult.error="..."; return defaultResult; }

                    try {
                        const hojasCalculadas = fitPiezasEnTablas(piezas, sw, sh); // Le pasamos piezas con shortCode
                        const numSheets = hojasCalculadas.length; const totalPrice = numSheets * price;

                        const boardData = hojasCalculadas.map(hoja => ({
                            id: hoja.id,
                            // 'ocupados' ahora también tiene 'shortCode' gracias a la modificación en fitPiezasEnTablas
                            pieces: hoja.ocupados.map(p => ({
                                id: p.id, etiqueta: p.etiqueta, color: p.color, shortCode: p.shortCode, // <-- Mapear shortCode
                                originalDim1: p.originalDim1, originalDim2: p.originalDim2,
                                x: p.x, y: p.y, w: p.w, h: p.h
                            }))
                        }));
                        return { count: numSheets, totalPrice: totalPrice, boardData: boardData, error: null };
                    } catch (error) { /* ... manejo error ... */
                         console.error("Error packing:", error);
                         defaultResult.error = error.message || "Error en cálculo de corte.";
                         return defaultResult;
                     }
                });

                // --- Métodos para el Template ---
                const getPieceStyle = (piece, currentSheetW, currentSheetH) => { /* SIN CAMBIOS */
                     const safeSheetW = currentSheetW > 0 ? currentSheetW : 1; const safeSheetH = currentSheetH > 0 ? currentSheetH : 1;
                     return { position: 'absolute', left: (piece.x/safeSheetW)*100+'%', top: (piece.y/safeSheetH)*100+'%', width: (piece.w/safeSheetW)*100+'%', height: (piece.h/safeSheetH)*100+'%', backgroundColor: piece.color };
                 };
                const getPieceTooltip = (piece) => { /* SIN CAMBIOS */
                     return `${piece.etiqueta} (${formatDecimal(piece.originalDim1)}x${formatDecimal(piece.originalDim2)})\nPos: (${piece.x.toFixed(1)}, ${piece.y.toFixed(1)})\nDim Colocada: ${piece.w.toFixed(1)}x${piece.h.toFixed(1)}\nID: ${piece.id}`;
                 };

                // --- Exponer al Template ---
                return {
                    largo, ancho, alto, espesor, sheetHeight, sheetWidth, boardPrice,
                    currentDateTime, piezasCalculadas, resultadoCorte,
                    formatDecimal, formatCurrency, getPieceStyle, getPieceTooltip,
                    currentSheetWidth: sheetWidth, currentSheetHeight: sheetHeight
                };
            }
        }).mount('#app');
    </script>

</body>
</html>